# Django Lesson Management System

Cервис для управления уроками с использованием Django, PostgreSQL, Redis и Celery. 
Реализует полный цикл управления уроком с асинхронными уведомлениями, валидацией и REST API.

## Технологический стек

-   **Django 5.2.9** — основной фреймворк с DRF
-   **PostgreSQL** — основная база данных
-   **Redis** — брокер для Celery и кеширование
-   **Celery** — фоновая обработка уведомлений
-   **Django REST Framework** — REST API
-   **DRF-YASG** — документация OpenAPI/Swagger
-   **Gunicorn** — WSGI-сервер для продакшена
-   **Docker Compose** — развертывание инфраструктуры
-   **Poetry** — управление зависимостями

## Инструменты разработки

-   **black** — автоматическое форматирование кода
-   **isort** — сортировка импортов

## Функциональные возможности

| Функция                     | Статус | Эндпоинт                              | Описание                                             |
| :-------------------------- | :----- | :------------------------------------ | :--------------------------------------------------- |
| Создание урока              | ✅     | `POST /api/v1/lessons/`               | Создание урока с автоматической валидацией           |
| Получение списка уроков     | ✅     | `GET /api/v1/lessons/`                | Пагинированный список всех уроков                    |
| Получение деталей урока     | ✅     | `GET /api/v1/lessons/{id}/`           | Детальная информация об уроке                        |
| Начало урока                | ✅     | `POST /api/v1/lessons/{id}/start/`    | Изменение статуса на "в процессе"                    |
| Завершение урока            | ✅     | `POST /api/v1/lessons/{id}/complete/` | Изменение статуса на "завершен"                      |
| Отмена урока                | ✅     | `POST /api/v1/lessons/{id}/cancel/`   | Изменение статуса на "отменен"                       |
| Уведомление о создании урока| ✅     | Celery задача                         | Асинхронная отправка уведомления                     |
| Уведомления об изменении статуса | ✅  | Celery задачи                         | Уведомления при start/complete/cancel                |
| Админ-панель Django         | ✅     | `/admin/`                             | Полное управление уроками и пользователями           |
| Автодокументация API        | ✅     | `/swagger/`, `/redoc/`                | Интерактивная документация OpenAPI                   |

## Быстрый старт с Docker Compose

### Предварительные требования

-   Docker 20.10+
-   Docker Compose 2.0+
-   Git

### Шаг 1: Клонирование репозитория

```bash
git clone https://github.com/Di-Nov/hello_world.git
```
```
cd hello_world
```
### Шаг 2: Настройка переменных окружения
Создайте файл .env на основе .env.template:

```bash
cp .env.template .env
```
Отредактируйте .env при необходимости.

### Шаг 3: Запуск инфраструктуры
```bash
docker-compose up -d --build
```
### Шаг 4: Проверка статуса
```bash
docker ps
```
Вы должны увидеть работающие контейнеры:

-   lesson_nginx (Nginx)
-   lesson_postgres (PostgreSQL)
-   lesson_redis
-   lesson_app (Django + Gunicorn)
-   lesson_celery_worker (Celery worker)

### Шаг 5: Доступ к сервисам

-   Django приложение: http://localhost
-   Swagger документация: http://localhost/swagger/
-   Admin панель: http://localhost/admin/  (Имя пользователя: root, Пароль: root)

### Шаг 5: Логи Celery Worker:
Здесь вы увидите процесс выполнения задачи в реальном времени:
```bash
docker logs -f lesson_celery_worker 
```
##### Почему 5-секундная задержка? Это имитация работы с внешним сервисом (SMTP, SMS-шлюз). Благодаря 4 воркерам, даже при такой задержке система может параллельно обрабатывать уведомления для 4 разных уроков, не блокируя очередь.

### Шаг 6: Изменим статус 3 уроков:
Это можно сделать через админку или swagger. 
На изменении статусов стоит валидация, ее можно посмотреть в методах модели lessons.models. 

Пример работы Celery
![Пример работы Celery](https://private-user-images.githubusercontent.com/117760934/530092944-fcb60af5-a94a-4bba-9c44-25f4be956047.png?jwt=eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJpc3MiOiJnaXRodWIuY29tIiwiYXVkIjoicmF3LmdpdGh1YnVzZXJjb250ZW50LmNvbSIsImtleSI6ImtleTUiLCJleHAiOjE3NjY2MTcwNjQsIm5iZiI6MTc2NjYxNjc2NCwicGF0aCI6Ii8xMTc3NjA5MzQvNTMwMDkyOTQ0LWZjYjYwYWY1LWE5NGEtNGJiYS05YzQ0LTI1ZjRiZTk1NjA0Ny5wbmc_WC1BbXotQWxnb3JpdGhtPUFXUzQtSE1BQy1TSEEyNTYmWC1BbXotQ3JlZGVudGlhbD1BS0lBVkNPRFlMU0E1M1BRSzRaQSUyRjIwMjUxMjI0JTJGdXMtZWFzdC0xJTJGczMlMkZhd3M0X3JlcXVlc3QmWC1BbXotRGF0ZT0yMDI1MTIyNFQyMjUyNDRaJlgtQW16LUV4cGlyZXM9MzAwJlgtQW16LVNpZ25hdHVyZT01MWU1ODRhNjZhZWY1MjA3NGUzYzc2MzM0Njc1ZDQ3ZWMzNWNlYmNiNmY5OGM3NjNkNGFmNGY4MzE3NTk4ZTAwJlgtQW16LVNpZ25lZEhlYWRlcnM9aG9zdCJ9.RgryYRTqNJP2JnCNBMS6LOp5_9zuCi8pfO52h8ub3sA)

#### Авторизация в админ-панели
При первом запуске автоматически создается суперпользователь:
Логин: root
Пароль: root
##### Важно: Это сделано только для удобства тестирования.

## Задание и ключевые решения
#### 1. Техническое задание 

Создать небольшой Django-проект, который демонстрирует следующее:
-   Модель: Создайте Django-модель Lesson (Урок) c полями на ваше усмотрение.
-   Бизнес-логика: Реализуйте механизм, который отслеживает важное событие в жизненном цикле урока — например, его создание или завершение.
-   Фоновая задача (Celery):
-   Когда это событие происходит, должна асинхронно запускаться задача Celery,что будет имитировать отправку уведомления студенту 
(например, просто логировать сообщение: "Уведомление отправлено студенту [ID студента] по уроку [Название урока]").

Что предоставить: Ссылку на Git-репозиторий (GitHub/GitLab) с вашим решением. Краткий README.md с инструкциями по запуску (включая Celery) обязателен.

#### 2. Асинхронная обработка уведомлений через Django Signals + Celery
Проблема: Отправка уведомлений — медленная операция. Если делать это синхронно в момент сохранения урока, это блокирует поток Django, ухудшая отклик API для пользователя.
Решение: Использование связки Django Signals и Celery.
Как это работает:
-   Пользователь вызывает API для изменения статуса урока (например, /complete/).
-   Django Signal pre_save срабатывает перед сохранением в базу. В этот момент мы извлекаем текущий (старый) статус урока из базы и кешируем его в Redis с уникальным ключом (с использованием временной метки для защиты от гонок).
-   Модель сохраняется в базу данных.
-   Django Signal post_save срабатывает после успешного сохранения. Мы извлекаем старый статус из кеша, сравниваем с новым и, если статус изменился, ставим соответствующую задачу в очередь Celery с помощью .delay().
-   Задача отправлена в celery, GIL освобождается для обработки других запросов.
-   Отдельный процесс Celery Worker (их запущено 4) забирает задачу из очереди Redis и выполняет её, имитируя отправку уведомления (задержка в 5 секунд).

Преимущества:

-   Не блокирует основной поток: API отвечает мгновенно, пользователь не ждет отправки уведомления.
-   Отказоустойчивость: Ошибка в задаче Celery (например, недоступность почтового сервера) не приведет к отказу в сохранении урока. Задача будет повторена.
-   Масштабируемость: Можно легко увеличить количество воркеров для обработки пиковой нагрузки.
-   Инкапсуляция бизнес-логики: Вся логика, связанная с реакцией на изменение урока, находится в одном месте (signals.py), а не размазана по разным View.

#### 2. Почему был выбран именно этот подход
Рассматривались альтернативы:
-   Паттерн Transactional Outbox: Максимально надежно. Событие об изменении записывается в отдельную таблицу в той же транзакции, что и изменение урока. Отдельный процесс гарантированно доставляет все события. Однако это сложнее в реализации и избыточно для данного тестового задания, где 99% надежности, обеспечиваемой связкой post_save + Celery, достаточно.
-   Отправка уведомлений из pre_save. Не надежно, так как при возникновении исключения при сохранении объекта модели в бд, уведомление ошибочно уйдет.
-   Прямой вызов .delay() из View: Работает, но нарушает принцип инкапсуляции и усложняет поддержку. В нашем решении View ничего не знает об уведомлениях.

Вывод: Решение с сигналами является оптимальным балансом между надежностью, производительностью, простотой реализации.


#### 4. Потенциальные улучшения

-   API уроков и распределение доступа к ним исходя из прав доступа, например: только учителя могут отменять уроки и только свои.
-   Модель пользователя: Расширить стандартную модель Django, добавив роли (админ, учитель, студент, менеджер), профили с фото, JWT-аутентификацию для API.
-   Тестирование: Написать unit-тесты для моделей, API-тесты с pytest-django, тесты для Celery-задач.
-   Мониторинг: Интегрировать Sentry для отслеживания ошибок, Flower для мониторинга очередей Celery.

### Так же можно развернуть проект локально для запуска приложения через IDE

#### 1. Клонировать репозиторий
```
git clone https://github.com/Di-Nov/hello_world.git
```
```
cd hello_world
```
#### 2. Установить зависимости
```
poetry install
```
#### 3. Активировать виртуальное окружение
```
poetry shell
```
#### 4. Запустить docker-compose для локальной разработки
```
docker-compose -f docker-compose.local.yml up -d --build
```
#### 5. Запустить миграции и создать тестовые данные
```
python manage.py migrate
```
```
python manage.py seed_data
```
#### 6. Запустить сервер для разработки
```
DJANGO_SETTINGS_MODULE=core.settings.local python manage.py runserver
```
